//! Module containing utilities for interfacing with the Balancer V2 Vault contract.

use anyhow::Result;
use contracts::BalancerV2Authorizer;
use ethcontract::{web3::signing, Bytes, H160};

mod sighash {
    use hex_literal::hex;

    pub const MANAGE_USER_BALANCE: [u8; 4] = hex!("0e8e3e84");
    pub const BATCH_SWAP: [u8; 4] = hex!("945bcec9");
}

fn role_id(target: H160, signature: [u8; 4]) -> Bytes<[u8; 32]> {
    let mut data = [0u8; 36];
    data[12..32].copy_from_slice(&target.0);
    data[32..36].copy_from_slice(&signature);
    Bytes(signing::keccak256(&data))
}

pub async fn grant_required_roles(
    authorizer: BalancerV2Authorizer,
    vault: H160,
    vault_relayer: H160,
) -> Result<()> {
    authorizer
        .grant_roles(
            vec![
                role_id(vault, sighash::MANAGE_USER_BALANCE),
                role_id(vault, sighash::BATCH_SWAP),
            ],
            vault_relayer,
        )
        .send()
        .await?;
    Ok(())
}

#[cfg(test)]
mod tests {
    use super::*;
    use hex_literal::hex;

    #[test]
    fn role_ids() {
        // These roles were generated by simulating `manageUserBalance` and
        // `batchSwap` transactions in Tenderly and then inspecting the `role`
        // value that was passed to the authenticator contract.

        const VAULT: H160 = addr!("BA12222222228d8Ba445958a75a0704d566BF2C8");

        assert_eq!(
            role_id(VAULT, sighash::MANAGE_USER_BALANCE),
            Bytes(hex!(
                "eba777d811cd36c06d540d7ff2ed18ed042fd67bbf7c9afcf88c818c7ee6b498"
            ))
        );
        assert_eq!(
            role_id(VAULT, sighash::BATCH_SWAP),
            Bytes(hex!(
                "1282ab709b2b70070f829c46bc36f76b32ad4989fecb2fcb09a1b3ce00bbfc30"
            ))
        );
    }
}
